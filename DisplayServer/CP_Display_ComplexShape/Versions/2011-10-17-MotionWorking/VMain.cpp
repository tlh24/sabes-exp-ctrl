#include "ATL_Defs.h"            // ATL,COM and Windows definitions
#include "resource.h"            // Resource IDs for registry
#include "CP_Display.h"          // this file is generated by MIDL compiler
#include "VMain.h"               // Uses ATL and IDs

#include <comdef.h>              // for _bstr_t

#include "GL_Engine.h"
#include "VObject.h"             // needed for VObject calls
#include "FrameCounter.h"
#include "Util\CP_printf.h"
#include "Util\VariantLib.h"
#include "TDT_UDP.h"

//==============================================================================
CVMain::CVMain() {
}

//==============================================================================
CVMain::~CVMain() {
	if(g_UDPsetupFlag) StopUDP();
}

//==============================================================================
HRESULT CVMain::GetVersion(  BSTR * pbstVersion ) {
  _bstr_t bscTmp(g_szVersion);
  *pbstVersion =  bscTmp.copy();
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::GetTransformMatrix( VARIANT * pvMtx){
  double * pdData;

  // Output 6x2 array of doubles
  if( g_MakeVariantArray( TRANSF_MTX_N_2, TRANSF_MTX_N_1, pvMtx, &pdData ) ){
    return g_ErrorToHresult(1);
  }

  memcpy( pdData, g_adTransfMtx, sizeof(g_adTransfMtx));
  SafeArrayUnaccessData( pvMtx->parray );

  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::SetTransformMatrix(VARIANT vMtx){
  double * pdData;

  // We expect 6x2 array of doubles
  if( g_CheckVariantArray( TRANSF_MTX_N_2, TRANSF_MTX_N_1, vMtx, &pdData )) {
    SafeArrayUnaccessData( vMtx.parray );
    return g_ErrorToHresult( 1 );
  }
  memcpy( g_adTransfMtx, pdData, sizeof(g_adTransfMtx));
  SafeArrayUnaccessData( vMtx.parray );
  return S_OK;
}

//-------------------------------------------------------
HRESULT CVMain::StartSync(){

  if( g_StartFrameCounter())
    CP_printf("Error: g_StartFrameCounter() failed!\n") ;
  return S_OK;
}

//-------------------------------------------------------
HRESULT CVMain::StopSync(){

  if( g_StopFrameCounter())
    CP_printf("Error: g_StopFrameCounter() failed!\n") ;
  return S_OK;
}

//-------------------------------------------------------
HRESULT CVMain::GetFrameCount( long * pnFrames ){
  g_GetFrameCounter( (int *)pnFrames );
  return S_OK;
}

  
  
  //==============================================================================
HRESULT CVMain::GetTimeScale( double *pdC0, double *pdC1 ){

  *pdC0 = g_dTimeOffset;
  *pdC1 = g_dTimeScale;

  return S_OK;
}

//==============================================================================
HRESULT CVMain::SetTimeScale( double dC0, double dC1 ){

  g_dTimeOffset = dC0;
  g_dTimeScale = dC1;

  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::StartBatchDraw(){
  g_blnBatchUpdate = 1;
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::FinishBatchDraw( long iLogID ){
  g_QueueLogEvent( iLogID );
  g_blnBatchUpdate = 0;  // reset batch mode
  g_blnDoRedraw = 1;     // redraw screen
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::MoveGroup(long iGroupID, VARIANT vXY, long iLogID){
  double * pdData;
  int iObj, nObjects;
  CVObject *pObj;

  // We expect 2-long array of doubles
  if( g_CheckVariantArray( 2, vXY, &pdData )) {
    return g_ErrorToHresult( 1 );
  }

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Move( pdData[0], pdData[1], iGroupID );
    else  pObj->Move( pdData[0], pdData[1]);
  }
  SafeArrayUnaccessData( vXY.parray );
  g_RequestUpdate(iLogID);

  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::ScaleGroup(long iGroupID, double dScale, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Scale(dScale, iGroupID );
    else pObj->Scale(dScale);
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::RotateGroup(long iGroupID, double dAngle, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Rotate(dAngle, iGroupID );
    else pObj->Rotate(dAngle);
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::HideGroup(long iGroupID, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Hide( iGroupID );
    else pObj->Hide();
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}
//==============================================================================
STDMETHODIMP CVMain::ShowGroup(long iGroupID, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Show( iGroupID );
    else  pObj->Show();
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::ResetEventLog(){
  g_ResetEventLog();
  g_nLogEvents = 1;
  g_iLastQueuedEvent = 0;


  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::GetEventLog(VARIANT * pvLogID, VARIANT * pvTimeStampMs){

  int * piData;
  double * pdData;

  if( g_MakeVariantArray( g_nLogEvents, pvLogID, &piData ) ){
    return g_ErrorToHresult(1);
  }

  memcpy( piData, g_aiLogIDs, sizeof(int) * g_nLogEvents);
  SafeArrayUnaccessData( pvLogID->parray );

  if( g_MakeVariantArray( g_nLogEvents, pvTimeStampMs, &pdData ) ){
    VariantClear( pvLogID );
    return g_ErrorToHresult(1);
  }

  memcpy( pdData, g_adEventTimes, sizeof(double) * g_nLogEvents);
  SafeArrayUnaccessData( pvTimeStampMs->parray );

  return S_OK;
}



// UDP INTERFACE

//==============================================================================
STDMETHODIMP CVMain::StartUDP(BSTR bstrIP)
{
	if(g_UDPsetupFlag) return S_OK;

    // open a UDP socket to the RZ unit

	// Deal with BSTR IP address 
	// Not sure if using _bstr_t is needed as intermediate to get type 
	// conversion to char *.
	// Needed for function inet_addr:
	//			unsigned long PASCAL FAR c (const char FAR * cp);
	//    
	 char *strIP;
	 _bstr_t bscIP;

	 bscIP = bstrIP;
	 strIP = (char *) bscIP;
	
	 // Make call
	 if( g_startUDP(strIP) ) return g_ErrorToHresult(1);

	 return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::StopUDP()
{
	 if( g_stopUDP() ) return g_ErrorToHresult(1);
	 return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::SendUDP(VARIANT dataVar, long iLogID)
{
	if(!g_UDPsetupFlag) return g_ErrorToHresult(1);
	
	int count,retval;
	double *data;
	   
	VariantToDoubleArray(&data, &dataVar);
	count = GetLength(data);

	retval = sendData(g_UDPsock,data,count);
	FreeDoubleArray(data);
	
	if(retval) return g_ErrorToHresult(1);
	
	g_RequestUpdate(iLogID);
	
	return S_OK;
}

