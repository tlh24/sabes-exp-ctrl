#include "ATL_Defs.h"            // ATL,COM and Windows definitions
#include "resource.h"            // Resource IDs for registry
#include "CP_Display.h"          // this file is generated by MIDL compiler
#include "VPolygon.h"            // Uses ATL and IDs

#include <math.h>
#include <gl\gl.h>               // Header File For The OpenGL32 Library
#include <gl\glu.h>              // Header File For The GLu32 Library

#include "GL_Engine.h"
#include "Util\CP_printf.h"
#include "Util\VariantLib.h"


#define N_TEX_SIZES 9
#define N_RGBA    4
int x_iaAllowedTextureSizes[N_TEX_SIZES] = { 2, 4, 8, 16, 32, 64, 128, 256, 512 };

//------------------------------------------------------------------------------
void x_tessErrorCallback(GLenum errorCode){
  CP_printf("Tessellation error %d:  %s \n" ,errorCode, gluErrorString( errorCode ));
}

//------------------------------------------------------------------------------
// This callback is useful when we have some extra data assosiated with a vertex,
// e.g. color. In this case we can calc data for the new vertex using data from
// its nearest 4 neighbours using 4 weights (their sum = 1)
// we use texture coordinates of the neighbours to calculate texture coordinates
// of the new vertex as a weighted sum
void CALLBACK x_tessCombineCallback(
                GLdouble adXYZ[3], // coordintates of the vertex to be ceated
                void      * apdVtxData[4], // pointers to the 4 nearest neighbours
                GLfloat  afWeight[4],    // weights of 4 neighbours
                void ** ppdNewVertex,    // new point output 
                void * pvData ){         // polygon data (this) pointer

  CVPolygon * ptPoly;
  ScrnVtxStruct * patVtx;
  ScrnVtxStruct ** patVtxNghbr;

  ptPoly = (CVPolygon *)pvData;
  patVtxNghbr = (ScrnVtxStruct **) apdVtxData;
  patVtx = &ptPoly->m_atTessVtx[ptPoly->m_nTessVtx];
  // copy GL-calculated coordinates to the new vertex
  patVtx->dX = adXYZ[0];
  patVtx->dY = adXYZ[1];
  patVtx->dZ = adXYZ[2];

  if( ptPoly->m_iUseTexture ){
    // calc texture coordinates of the new vertex
    // it is just a weighted sum of neighbor's coordinates
    patVtx->dTexX = 
          patVtxNghbr[0]->dTexX * afWeight[0] +
          patVtxNghbr[1]->dTexX * afWeight[1] +
          patVtxNghbr[2]->dTexX * afWeight[2] +
          patVtxNghbr[3]->dTexX * afWeight[3];
    patVtx->dTexY = 
          patVtxNghbr[0]->dTexY * afWeight[0] +
          patVtxNghbr[1]->dTexY * afWeight[1] +
          patVtxNghbr[2]->dTexY * afWeight[2] +
          patVtxNghbr[3]->dTexY * afWeight[3];
  }

  * ppdNewVertex = patVtx; // return the pointer
  ptPoly->m_nTessVtx++; // next index 
}
 
//------------------------------------------------------------------------------
void CALLBACK x_tessVertexTexCallback( void * pvData ){
  ScrnVtxStruct * patVtx;

  patVtx = (ScrnVtxStruct *) pvData;
  glTexCoord2d(patVtx->dTexX, patVtx->dTexY);
  glVertex3dv((double *)pvData);
}

//==============================================================================
CVPolygon::CVPolygon(){

  double adRGBA[4][2][2];

  m_nTessVtx = 0;
  m_atPhysVtx = NULL;
  m_atScrnVtx = NULL;
  m_atTessVtx = NULL;

  // by default  polygon is a square with side 1
  m_nVertices = 4;
  m_NewVertices();
  m_atPhysVtx[0].dX = 0.5;
  m_atPhysVtx[0].dY = 0.5;
  m_atPhysVtx[1].dX = -0.5;
  m_atPhysVtx[1].dY = 0.5;
  m_atPhysVtx[2].dX = -0.5;
  m_atPhysVtx[2].dY = -0.5;
  m_atPhysVtx[3].dX = 0.5;
  m_atPhysVtx[3].dY = -0.5;

  // tessellation
  m_Tess = gluNewTess();
  gluTessCallback(m_Tess, GLU_TESS_BEGIN, (void(CALLBACK*)()) glBegin);
  gluTessCallback(m_Tess, GLU_TESS_COMBINE_DATA, (void(CALLBACK*)()) x_tessCombineCallback);
  gluTessCallback(m_Tess, GLU_TESS_END, glEnd);
  gluTessCallback(m_Tess, GLU_TESS_ERROR, (void(CALLBACK*)()) x_tessErrorCallback);

  // default texture is checker board
  m_iUseTexture = 0;
  m_dTexturePhysWidth = 0.1;

  adRGBA[0][0][0] = 0.125; // Red
  adRGBA[1][0][0] = 0.55;  // Green
  adRGBA[2][0][0] = 0.25;  // Blue
  adRGBA[3][0][0] = 1;     // Alpha

  adRGBA[0][1][0] = 0;     // Red
  adRGBA[1][1][0] = 0;     // Green
  adRGBA[2][1][0] = 0;     // Blue
  adRGBA[3][1][0] = 0;     // Alpha

  adRGBA[0][0][1] = 0;     // Red
  adRGBA[1][0][1] = 0;     // Green
  adRGBA[2][0][1] = 0;     // Blue
  adRGBA[3][0][1] = 0;     // Alpha

  adRGBA[0][1][1] = 0.125; // Red
  adRGBA[1][1][1] = 0.55;  // Green
  adRGBA[2][1][1] = 0.25;  // Blue
  adRGBA[3][1][1] = 1;     // Alpha

  m_nTextureW = 2;
  m_nTextureH = 2;
  m_pfTexture = NULL;
  m_NewTexture( (double *) adRGBA );

}

//==============================================================================
CVPolygon::~CVPolygon(){
  glDeleteTextures(1, &m_uiTextureID);
  gluDeleteTess(m_Tess);
  if( m_atPhysVtx ) delete m_atPhysVtx;
  if( m_atScrnVtx ) delete m_atScrnVtx;

  if( m_atTessVtx ) delete m_atTessVtx;
  if( m_pfTexture ) delete m_pfTexture;
}

#define VOBJECT CVPolygon  // this define is needed for <VObjectMethodsImpl.h>
#include "VObjectMethodsImpl.h"  // common methods are here

//==============================================================================
//                   polygon-specific methods
//==============================================================================
STDMETHODIMP CVPolygon::GetVertices(VARIANT * pvVertices){
  double * pdData;

  if( g_MakeVariantArray( 2, m_nVertices, pvVertices, &pdData ) ){
    return g_ErrorToHresult(1);
  }

  memcpy(pdData, m_atPhysVtx, m_nVertices * sizeof(XY_VtxStruct));
  SafeArrayUnaccessData( pvVertices->parray );

  return S_OK;

}

//==============================================================================
STDMETHODIMP CVPolygon::SetVertices(VARIANT vVertices, long iLogID){
  double * pdData;
  int nVertices;

  // We expect 2xN array of doubles
  if( g_CheckVariantArray( 2, &nVertices, vVertices, &pdData )) {
    return g_ErrorToHresult( 1 );
  }
  if( nVertices < 3 ) {
    return g_ErrorToHresult( 1 );
  }
  m_nVertices = nVertices;
  m_NewVertices();
  memcpy(m_atPhysVtx, pdData, nVertices * sizeof(XY_VtxStruct));

  SafeArrayUnaccessData( vVertices.parray );
  m_RequestUpdate(iLogID);

  return S_OK;
}

//==============================================================================
// Matlab's DCOM cannot receive multidimensional arrays, i.e. N dims > 2
// We have to use 1-D SAFEARRAY inside VARIANT. Actual dimesions are
// N_pix_Width x N_pix_Height x N_RGBA, values are doubles
STDMETHODIMP CVPolygon::GetTexture( VARIANT * pvTexture,
                                    long * pnPixelsW,
                                    long * pnPixelsH,
                                    double * pdTexturePhysWidth ) {

  double * pdData;
  int i, nVals;

  * pnPixelsW = m_nTextureW;
  * pnPixelsH = m_nTextureH;
  * pdTexturePhysWidth = m_dTexturePhysWidth;

  nVals = m_nTextureW * m_nTextureH * N_RGBA;
  if( g_MakeVariantArray( nVals, pvTexture, &pdData ) ){
    return g_ErrorToHresult(1);
  }

  for(i=0; i<nVals; i++)
    pdData[i] = m_pfTexture[i];
  SafeArrayUnaccessData( pvTexture->parray );

  return S_OK;
}

//==============================================================================
STDMETHODIMP CVPolygon::SetTexture( VARIANT vTexture,
                                    double dTexturePhysWidth,
                                    long iLogID ) {
  double * pdData;
  int nPixelsW, nPixelsH;
  int i, iW_Ok, iH_Ok;

  // We expect NxNxN_RGBA array of doubles
  if( g_CheckVariantArray( &nPixelsH, &nPixelsW, N_RGBA, vTexture, &pdData )) {
    return g_ErrorToHresult( 1 );
  }

  iW_Ok = 0; iH_Ok = 0;
  for( i=0; i<N_TEX_SIZES; i++){
    if( nPixelsW == x_iaAllowedTextureSizes[i]) iW_Ok = 1;
    if( nPixelsH == x_iaAllowedTextureSizes[i]) iH_Ok = 1;
  }
  if( !(iW_Ok && iH_Ok )){
    CP_printf("Invalid texture size: %d x %d\nTexture size should be a power of 2\n", 
                                nPixelsW, nPixelsH);
    SafeArrayUnaccessData( vTexture.parray );
    return g_ErrorToHresult( 1 );
  }

  m_nTextureW = nPixelsW;
  m_nTextureH = nPixelsH;
  m_dTexturePhysWidth = dTexturePhysWidth;

  m_NewTexture( pdData );

  SafeArrayUnaccessData( vTexture.parray );
  m_RequestUpdate(iLogID);

  return S_OK;
}

//==============================================================================
STDMETHODIMP CVPolygon::GetTextureFlag( long * plngTextureFlag) {

  *plngTextureFlag = m_iUseTexture;

  return S_OK;
}


//==============================================================================
STDMETHODIMP CVPolygon::SetTextureFlag( long lngTextureFlag, long iLogID) {

  m_iUseTexture = lngTextureFlag && TRUE;  // convert to 0/1
  m_RequestUpdate(iLogID);
  return S_OK;
}


//==============================================================================
void CVPolygon::m_NewVertices(){

  if( m_atPhysVtx ) delete m_atPhysVtx;
  if( m_atScrnVtx ) delete m_atScrnVtx;
  if( m_atTessVtx ) delete m_atTessVtx;

  m_atPhysVtx = new XY_VtxStruct[m_nVertices];
  m_atScrnVtx = new ScrnVtxStruct[m_nVertices];
  m_atTessVtx = new ScrnVtxStruct[m_nVertices];
  m_nTessVtx = 0;

}

//==============================================================================
void CVPolygon::m_NewTexture( double * pdData ){
  int iRow, iCol, iRGBA, nVals;
  float * pfDest;
  double * pdSrc;

  if( m_pfTexture ) {
    glDeleteTextures(1, &m_uiTextureID);
    delete m_pfTexture;
  }

  nVals = m_nTextureW * m_nTextureH * N_RGBA;
  m_pfTexture = new float[nVals];

  // Reverse the order of rows. 
  // Bitmaps are stored top->bottom, OpenGL draws bottom->top
  // Also index order of input array is the opposite of the OpenGL's
  pfDest = m_pfTexture;
  pdSrc = pdData;
  for( iRow=0; iRow < m_nTextureH; iRow++ ){
    for ( iCol = 0; iCol < m_nTextureW; iCol++ ){
      for( iRGBA = 0; iRGBA < N_RGBA; iRGBA++ ) {
//        * pfDest++ = (float) * pdSrc++;
        * pfDest++ = (float)pdData[ (iRGBA * m_nTextureW * m_nTextureH) // 1st index - RGBA
                                    + (iCol * m_nTextureW)  // 2nd index - X
                                    + (m_nTextureH - iRow -1) ];  // 3rd index - Y (inverted)
      }
    }
  }

  glGenTextures(1, &m_uiTextureID);  // Get new texture ID
  glBindTexture(GL_TEXTURE_2D, m_uiTextureID);  // start working with this ID
  glTexImage2D(GL_TEXTURE_2D, 
               0,          // level of detail 0=full
               GL_RGBA,    // requested number of color components
               m_nTextureW, m_nTextureH,  // image size
               0,         // border width ( 0 == no border)
               GL_RGBA,   // pixel format of input
               GL_FLOAT,  // type of input
               m_pfTexture );
  // texture will repeat in both directions
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  // no interpolation of the texture bitmap
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  // linear interpolation of the texture bitmap
//  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
//  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);

  // now the texture image and all texture drawing options
  // are bound to the m_uiTextureID
  // next time we call glBindTexture(GL_TEXTURE_2D, m_uiTextureID);
  // all settings will be restored


}

//==============================================================================
void CVPolygon::m_CalcScrnVertices(){

  int iVtx;
  double dPhysX, dPhysY;
  double dX, dY;
  double dSin, dCos;
  double dTexScaleX, dTexScaleY;

  dSin = sin( m_dAngle * DEGS_TO_RADS );
  dCos = cos( m_dAngle * DEGS_TO_RADS );
  dTexScaleX = 1.0/m_dTexturePhysWidth;
  dTexScaleY = m_nTextureW / (m_dTexturePhysWidth * m_nTextureH);
  for( iVtx = 0; iVtx < m_nVertices; iVtx++){
    dPhysX = m_atPhysVtx[iVtx].dX;
    dPhysY = m_atPhysVtx[iVtx].dY;
    // rotate, scale and shift
    dX = (dPhysX * dCos - dPhysY * dSin ) * m_dScale + m_dX;
    dY = (dPhysX * dSin + dPhysY * dCos ) * m_dScale + m_dY;
    g_TransformCoordinatesD( dX, dY, &m_atScrnVtx[iVtx].dX, &m_atScrnVtx[iVtx].dY );
    m_atScrnVtx[iVtx].dZ = m_dZ;

    // Texture coordinates are in [0,1] range (relative to the bitmap W,H)
    m_atScrnVtx[iVtx].dTexX = dPhysX * dTexScaleX + 0.5;
    m_atScrnVtx[iVtx].dTexY = dPhysY * dTexScaleY + 0.5;
  }

}

//==============================================================================
void CVPolygon::Draw() {
  int iVtx;

  m_nClipped = 0;
  if(!m_IsVisible) return;
  if( m_nVertices < 3 ) return;

  m_CalcScrnVertices();
  if( m_iUseTexture ){
    gluTessCallback(m_Tess, GLU_TESS_VERTEX, 
                   (void(CALLBACK*)()) x_tessVertexTexCallback);
    glEnable(GL_TEXTURE_2D);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    glBindTexture(GL_TEXTURE_2D, m_uiTextureID);
  }
  else{
//    glDisable(GL_TEXTURE_2D);
    gluTessCallback(m_Tess, GLU_TESS_VERTEX, 
                   (void(CALLBACK*)()) glVertex3dv);
    glColor4f( m_fRGB[0], m_fRGB[1], m_fRGB[2], m_fAlpha);
    // filled/contour mode
    gluTessProperty(m_Tess,GLU_TESS_BOUNDARY_ONLY, !m_iIsFilled );
  }

  // if we did rotate around a point CW or CCW, it is inside
  gluTessProperty(m_Tess,GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO );

  m_nTessVtx = 0;
  gluTessBeginPolygon(m_Tess, (void *) this );
  gluTessBeginContour(m_Tess);
  // we cannot use local vars to represent the vertices
  // they have to be persistent: GL will use them later
  for( iVtx = 0; iVtx < m_nVertices; iVtx++){
    m_nClipped += IS_OFF_WINDOW(m_atScrnVtx[iVtx].dX,m_atScrnVtx[iVtx].dY);
    gluTessVertex( m_Tess,  
                  (double *) &m_atScrnVtx[iVtx],  // vertex in screen coordinates
                  (double *) &m_atScrnVtx[iVtx]); // pointer to user vertex data , will be passed to the
                                                  // vertex callback
  }
  gluTessEndContour(m_Tess);
  gluTessEndPolygon(m_Tess);

  if( m_iUseTexture ){
    glDisable(GL_TEXTURE_2D);
  }

}

