#include "ATL_Defs.h"            // ATL,COM and Windows definitions
#include "resource.h"            // Resource IDs for registry
#include "CP_Display.h"          // this file is generated by MIDL compiler
#include "VMain.h"               // Uses ATL and IDs

#include <comdef.h>              // for _bstr_t

#include "GL_Engine.h"
#include "VObject.h"             // needed for VObject calls
#include "FrameCounter.h"
#include "Util\CP_printf.h"
#include "Util\SafeArrayLib.h"

//==============================================================================
CVMain::CVMain() {

}

//==============================================================================
CVMain::~CVMain() {

}

//==============================================================================
HRESULT CVMain::GetVersion(  BSTR * pbstVersion ) {
  _bstr_t bscTmp(g_szVersion);
  *pbstVersion =  bscTmp.copy();
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::GetTransformMatrix(SAFEARRAY  ** ppsaMtx){
  SAFEARRAY *psaMtx;
  double * pData;

  // Output 6x2 array of doubles
  if( g_MakeSafeArray( TRANSF_MTX_N_2, TRANSF_MTX_N_1, &psaMtx, &pData ) ){
    return g_ErrorToHresult(1);
  }

  memcpy( pData, g_adTransfMtx, sizeof(g_adTransfMtx));
  SafeArrayUnaccessData( psaMtx );

  * ppsaMtx = psaMtx;
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::SetTransformMatrix(SAFEARRAY * psaMtx){
  double * pData;

  // We expect 6x2 array of doubles
  if( g_CheckSafeArray( TRANSF_MTX_N_2, TRANSF_MTX_N_1, psaMtx, &pData )) {
    return g_ErrorToHresult( 1 );
  }

  memcpy( g_adTransfMtx, pData, sizeof(g_adTransfMtx));
  SafeArrayUnaccessData( psaMtx );

  return S_OK;
}

//-------------------------------------------------------
HRESULT CVMain::StartSync(){

  if( g_StartFrameCounter())
    CP_printf("Error: g_StartFrameCounter() failed!\n") ;
  return S_OK;
}

//-------------------------------------------------------
HRESULT CVMain::StopSync(){

  if( g_StopFrameCounter())
    CP_printf("Error: g_StopFrameCounter() failed!\n") ;
  return S_OK;
}

//==============================================================================
HRESULT CVMain::GetTimeScale( double *pdC0, double *pdC1 ){

  *pdC0 = g_dTimeOffset;
  *pdC1 = g_dTimeScale;

  return S_OK;
}

//==============================================================================
HRESULT CVMain::SetTimeScale( double dC0, double dC1 ){

  g_dTimeOffset = dC0;
  g_dTimeScale = dC1;

  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::StartBatchDraw(){
  g_blnBatchUpdate = 1;
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::FinishBatchDraw( long iLogID ){
  g_QueueLogEvent( iLogID );
  g_blnBatchUpdate = 0;  // reset batch mode
  g_blnDoRedraw = 1;     // redraw screen
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::MoveGroup(long iGroupID, SAFEARRAY * psaXY, long iLogID){
  double * pdData;
  int iObj, nObjects;
  CVObject *pObj;

  // We expect 2-long array of doubles
  if( g_CheckSafeArray( 2, psaXY, &pdData )) {
    return g_ErrorToHresult( 1 );
  }

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Move( pdData[0], pdData[1], iGroupID );
    else  pObj->Move( pdData[0], pdData[1]);
  }
  SafeArrayUnaccessData( psaXY );
  g_RequestUpdate(iLogID);
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::ScaleGroup(long iGroupID, double dScale, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Scale(dScale, iGroupID );
    else pObj->Scale(dScale);
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::RotateGroup(long iGroupID, double dAngle, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Rotate(dAngle, iGroupID );
    else pObj->Rotate(dAngle);
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::HideGroup(long iGroupID, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Hide( iGroupID );
    else pObj->Hide();
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}
//==============================================================================
STDMETHODIMP CVMain::ShowGroup(long iGroupID, long iLogID){
  int iObj, nObjects;
  CVObject *pObj;

  nObjects = g_ptObjectList.GetN_Pointers();
  
  for( iObj = 0; iObj<nObjects; iObj++){
    g_ptObjectList.GetPointer( iObj, (void **) &pObj);
    if(iGroupID) pObj->Show( iGroupID );
    else  pObj->Show();
  }

  g_RequestUpdate(iLogID);
  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::ResetEventLog(){
  g_ResetEventLog();
  g_nLogEvents = 1;
  g_iLastQueuedEvent = 0;


  return S_OK;
}

//==============================================================================
STDMETHODIMP CVMain::GetEventLog(SAFEARRAY** ppsaLogID, SAFEARRAY** ppsaTimeStampMs){
  SAFEARRAY *psaMtx;
  int * piData;
  double * pdData;

  * ppsaLogID =NULL;
  * ppsaTimeStampMs = NULL;

  if( g_MakeSafeArray( g_nLogEvents, &psaMtx, &piData ) ){
    return g_ErrorToHresult(1);
  }

  memcpy( piData, g_aiLogIDs, sizeof(int) * g_nLogEvents);
  SafeArrayUnaccessData( psaMtx );
  * ppsaLogID = psaMtx;

  if( g_MakeSafeArray( g_nLogEvents, &psaMtx, &pdData ) ){
    return g_ErrorToHresult(1);
  }
  memcpy( pdData, g_adEventTimes, sizeof(double) * g_nLogEvents);
  SafeArrayUnaccessData( psaMtx );
  * ppsaTimeStampMs = psaMtx;

  return S_OK;
}


