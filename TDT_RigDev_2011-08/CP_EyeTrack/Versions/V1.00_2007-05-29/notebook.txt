http://www.installshield.com/news/newsletter/0209-articles/cppautomation.asp

#include <comdef.h>
#include <iostream>

using namespace std;

// import information from type library
#import "C:\Program Files\InstallShield\Developer\System\iswiautomation.dll" no_namespace

int main(int argc, char *argv[])
{
    // initialize COM
    CoInitialize(NULL);

    try
    {
        // instantiate the Developer Automation interface
        _ISWiProjectPtr oISM(__uuidof(ISWiProject));

        // open project read-write
        oISM->OpenProject(_bstr_t("C:\\MySetups\\Auto.ism"), VARIANT_FALSE);

        // ...perform changes...

        // save changes and clean up
        oISM->SaveProject( );
        oISM->CloseProject( );
    }
    catch(_com_error e)
    {
        // handle exceptions
        cout << "*** Exception: " << (const char*)(e.Description( )) << endl;
    }

    CoUninitialize( );
    return 0;
}

The #import preprocessor directive imports information from the Developer Automation type library (it may be necessary for you to adjust the command to point to the path of IswiAutomation.dll on your system; note that the directive uses single backslashes, and not double backslashes). When you compile code that uses the #import directive, Visual C++ creates a header file with the .tlh extension that contains the C++ equivalents of the methods you can use in VBScript.

The IswiAutomation.tlh file generated by this example contains the prototypes and definitions of the of the classes, properties, and methods used in the Automation interface; for example, the .tlh file defines the _ISWiProjectPtr smart-pointer type and ISWiProject class used in the code example above. (There is also a .tli file, containing wrapper implementations of the methods in the type library, which is not covered here.)

============================================================================================================================================
http://www.codeguru.com/Cpp/COM-Tech/activex/tutorials/article.php/c5567/#Step15



Step 15:
A Visual C++ client can use use COM interfaces through any of the following:

    * #import "IAdd.tlb" .
    * IAdd.h header file. In this case the DLL vendor must ship the IAdd.h header file along with the DLL.
    * Generate C++ code using some wizard sort of a tool(eg: MFC's Class Wizard)

In Case 1, the compiler creates some intermediate files (.tlh, tli) that contain the expanded interface declarations. Further, the compiler also declares smart interface pointer classes built around the raw interfaces. Smart interface pointer classes make life easier for the COM programmer by properly managing the lifetime of the COM object.
In the following example #import has been done on the file AddObj.dll and not on the IAdd.tlb, because we are shipping the TLB file within the DLL. Otherwise, #import should have been done on the TLB.
Create a new console EXE project in VC++. Type the following contents and compile.

//
///Client.cpp
//
//Demo of client using the COM object from AddObj.dll
//

#include    <objbase.h>
#include    <stdio.h>
#import     "AddObj.dll"
//
//Here we do a #import on the DLL ,you can also do a #import on the .TLB
//The #import directive generates two files (.tlh/.tli) in the output folders.
//

void main()
    {

    long n1 =100, n2=200;
    long nOutPut = 0;

    CoInitialize(NULL);
    CodeGuruMathLib::IAddPtr pFastAddAlgorithm;
    //
    //IAddPtr is not the actual interface IAdd, but a template C++ class (_com_ptr_t)
    //that contains an embedded instance of the raw IAdd pointer
    //While destructing , the destructor makes sure to invoke Release() on the internal
    //raw interface pointer. Further, the operator -> has been overloaded to direct all
    //method invocations to the internal raw interface pointer.
    //
    pFastAddAlgorithm.CreateInstance("CodeGuru.FastAddition");

    pFastAddAlgorithm->SetFirstNumber(n1);//"->" overloading in action
    pFastAddAlgorithm->SetSecondNumber(n2);
    nOutPut = pFastAddAlgorithm->DoTheAddition();

    printf("\nOutput after adding %d & %d is %d\n",n1,n2,nOutPut);


    }

